# 简述JVM内存模型和内存区域

**内存模型：**

Java 内存模型规定了所有的变量都是存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

![](https://camo.githubusercontent.com/417cc54bb8faab95e63a93d78488a92ff6baaf05/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31312f30352f356264666362313334373161382e6a7067)

**内存区域：**

![](https://camo.githubusercontent.com/c44e078a4b3eff770561f2c201c535c1c5c14917/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31312f30352f356264666365353738633035352e6a7067)

内存区域可以分为以下几块：

* 程序计数器

    程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值为空。此内存区域是唯一一个没有规定任何 OOM 的区域。

* 虚拟机栈

    虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈桢用于存储局部变量表、操作数栈、动态链接地址、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机中入栈到出栈的过程。

* 本地方法栈

    本地方法栈和虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机执行 Native 方法服务。

* 堆

    Java 堆是虚拟机管理的内存中最大的一块，此内存的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

* 方法区

    用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。相对而言，垃圾回收在这个区域是比较少出现的。

> [Java内存模型](https://www.jianshu.com/p/13b56ddad197)  
> [Java内存区域](https://www.jianshu.com/p/2f0742032ab3)

## jvm内存模型，新生代和老年代的比例？

1 : 2

## 新生代里怎么划分？好处？

新生代又被划分为三个区域：Eden、From Survivor、To Survivor。

这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

![](https://images0.cnblogs.com/blog/587773/201409/061921034534396.png)

JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。