>  [对象池——利弊与使用场景](https://blog.csdn.net/lemon89/article/details/80718976)
>
> ## 对象池的优点
>
> **复用池中对象,消除创建对象、回收对象 所产生的内存开销、cpu开销以及(若跨网络)产生的网络开销.**
>
> 常见的使用对象池有：在使用socket时(包括各种连接池)、线程等等
>
> ## 对象池的缺点:
>
> - 现在Java的对象分配操作不比c语言的malloc调用慢, 对于轻中量级的对象, 分配/释放对象的开销可以忽略不计;
> - 并发环境中, 多个线程可能(同时)需要获取池中对象, 进而需要在堆数据结构上进行同步或者因为锁竞争而产生阻塞, 这种开销要比创建销毁对象的开销高数百倍;
> - 由于池中对象的数量有限, 势必成为一个可伸缩性瓶颈;
> - 很难正确的设定对象池的大小, 如果太小则起不到作用, 如果过大, 则占用内存资源高,
>
> ## 对象池有其特定的适用场景:
>
> - 受限的, 不需要可伸缩性的环境(cpu\内存等物理资源有限): cpu性能不够强劲, 内存比较紧张, 垃圾收集, 内存抖动会造成比较大的影响, 需要提高内存管理效率, 响应性比吞吐量更为重要;
> - 数量受限的资源, 比如数据库连接;
> - 创建成本高昂的对象, 可斟酌是否池化, 比较常见的有线程池（ThreadPoolExecutor）, 字节数组池等;