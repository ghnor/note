我们编写的java文件，从生到死的主要过程有：

1. 通过javac编译器编译为class文件
2. 通过类加载器加载到内存
3. JVM运行时优化
4. 垃圾回收

期间还涉及到Java内存模型。

所以这里按照顺序依次讲解，由于讲内存模型必然会讲到锁，所以锁也会在这里讲述，
Annotation也会在这里涉及

首先我们来讲一下JVM虚拟机/Dalvik虚拟机/ART虚拟机

## JVM虚拟机/Dalvik虚拟机/ART虚拟机

### JVM虚拟机和DVM虚拟机区别

DVM就是Dalvik Virtual Machine，是Android中使用的虚拟机，所有Android程序都运行在Android系统进程里，每个进程对应着一个Dalvik虚拟机实例。

JAVA虚拟机运行的是JAVA字节码，Dalvik虚拟机运行的是Dalvik字节码（DEX）

* JVM基于栈，DVM基于寄存器
    * JAVA虚拟机基于栈结构，程序在运行时虚拟机需要频繁的从栈上读取写入数据，会耗费很多CPU时间
    * Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递

* Dalvik可执行文件体积更小
    * dx工具对JAVA类文件重新排列，所有的类文件共享同一个常量池，使得相同的字符串、常量在DEX文件中只出现一次

> 作者：RednaxelaFX  
> 链接：https://www.zhihu.com/question/35777031/answer/64575683  
> 来源：知乎  
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

> [虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩](https://www.iteye.com/blog/rednaxelafx-492667)

基于栈与基于寄存器的指令集，用在解释器里，笼统说有以下对比：

* 从源码生成代码的难度：基于栈 < 基于寄存器，不过差别不是特别大
* 表示同样程序逻辑的代码大小（code size）：基于栈 < 基于寄存器
* 表示同样程序逻辑的指令条数（instruction count）：基于栈 > 基于寄存器
* 简易实现中数据移动次数（data movement count）：基于栈 > 基于寄存器；不过值得一提的是实现时通过栈顶缓存（top-of-stack caching）可以大幅降低基于栈的解释器的数据移动开销，可以让这部分开销跟基于寄存器的在同等水平。请参考另一个回答：寄存器分配问题？ - RednaxelaFX 的回答
* 采用同等优化程度的解释器速度：基于栈 < 基于寄存器
* 交由同等优化程度的JIT编译器编译后生成的代码速度：基于栈 === 基于寄存器

因而，笼统说可以有以下结论：
* 要追求尽量实现简单：选择基于栈
* 传输代码的大小尽量小：选择基于栈
* 纯解释执行的解释器的速度：选择基于寄存器
* 带有JIT编译器的执行引擎的速度：随便，两者一样；对简易JIT编译器而言基于栈的指令集可能反而更便于生成更快的代码，而对比较优化的JIT编译器而言输入是基于栈还是基于寄存器都无所谓，经过parse之后就变得完全一样了。

基于栈的设计并没有让Java的代码传输大小减小多少。
这是因为：Java代码是以Class文件为单位来传输与存储的。

Java从设计之初就非要支持分离编译（separate compilation）与按需动态类加载（on-demand dynamic class loading），导致Java的Class文件必须独立的（self-contained）——每个Class文件必须自己携带自己的常量池，其主要信息是字符串与若干其它常量的值，以及用于符号链接的符号引用信息（symbolic reference）。

如果大家关注过Class文件的内容的话，会知道其实通常Class文件里表示程序逻辑的代码部分——“字节码”——只占Class文件大小的小头；而大头都被常量池占了。而且多个Class文件的常量池内容之间常常有重叠，所以当程序涉及多个Class文件时，就容易有冗余信息，不利于减少传输/存储代码的大小。

> **class与dex对比：**

1. class文件存在许多冗余信息，一个类就要有一个常量池
2. dex会去除冗余并整合，所有的源文件中所有的数据是存在一个数据区的，可以减少体积

### ART虚拟机（Android Run Time）

* JIT（Just In Time，即时编译技术）
    * JIT编译器在JVM运行时优化时会详细讲到
* AOT(Ahead Of Time，预编译技术)
    * AOT编译器在编译时直接将程序源码编译成目标机器码，运行时直接运行机器码

ART虚拟机：它采用AOT技术，会在应用程序安装时就转换成机器语言，不再在执行时解释，从而优化了应用运行的速度。

Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。

ART优点：

* 系统性能显著提升
* 应用启动更快、运行更快、体验更流畅、触感反馈更及时

ART缺点：

* 更大的存储空间占用，可能增加10%-20%
* 更长的应用安装时间

总的来说ART就是“空间换时间”

## javac编译器

编译过程：

1. 解析与填充符号表；
2. 处理注解；
3. 分析与字节码生成

### 解析与填充符号表

解析：包括了词法分析（将代码转化为Token合集）和语法分析（将Token合集转化为抽象语法树）

填充符号表：根据抽象语法树生成符号表（符号信息和符号地址组成的KV表格，一个统称，有常数表、变量名表、数组名表、过程名表、标号表等，用于语义分析和生成中间代码、生成目标代码）。

解析完成后就不会对源码进行操作了，后面基本都是根据抽象语法树来操作。

### 处理注解：

注解处理器可将其看做编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素，如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止。

### 分析与字节码生成

#### 语义分析

语义分析包含：
* 标注检查，
* 数据及控制流分析，
* 解语法糖

标注检查步骤检查的内容如变量使用前是否已经被声明、变量与赋值之间的数据类型是否匹配等。

数据及控制流分析是对程序上下文逻辑更进一步的验证，可以检查出诸如程序局部变量是否在使用前有赋值、方法的每条路径是否都有返回值、是否所有的受检异常都被正确处理等。

Java中常见的语法糖有：泛型、自动装箱、自动拆箱、变长参数、内部类、枚举类、字符串的switch支持等

#### 字节码生成

编译器会把语句块、变量初始化、调用父类的实例构造器等操作收敛到<init>()或<clinit>()方法之中，并且保证一定是先执行父类的实例构造器。 完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给ClassWriter类，由这个类的writeClass()方法输出字节码，生成最终的Class文件