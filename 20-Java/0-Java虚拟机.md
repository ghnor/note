我们编写的java文件，从生到死的主要过程有：

1. 通过javac编译器编译为class文件
2. 通过类加载器加载到内存
3. JVM运行时优化
4. 垃圾回收

期间还涉及到Java内存模型。

所以这里按照顺序依次讲解，由于讲内存模型必然会讲到锁，所以锁也会在这里讲述，
Annotation也会在这里涉及

> ## javac编译器
>
> 编译过程：
>
> 1. 解析与填充符号表；
> 2. 处理注解；
> 3. 分析与字节码生成
>
> ### 解析与填充符号表
>
> 解析：包括了词法分析（将代码转化为Token合集）和语法分析（将Token合集转化为抽象语法树）
>
> 填充符号表：根据抽象语法树生成符号表（符号信息和符号地址组成的KV表格，一个统称，有常数表、变量名表、数组名表、过程名表、标号表等，用于语义分析和生成中间代码、生成目标代码）。
>
> 解析完成后就不会对源码进行操作了，后面基本都是根据抽象语法树来操作。
>
> ### 处理注解：
>
> 注解处理器可将其看做编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素，如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止。
>
> ### 分析与字节码生成
>
> #### 语义分析
>
> 语义分析包含：
>
> * 标注检查，
> * 数据及控制流分析，
> * 解语法糖
>
> 标注检查步骤检查的内容如变量使用前是否已经被声明、变量与赋值之间的数据类型是否匹配等。
>
> 数据及控制流分析是对程序上下文逻辑更进一步的验证，可以检查出诸如程序局部变量是否在使用前有赋值、方法的每条路径是否都有返回值、是否所有的受检异常都被正确处理等。
>
> Java中常见的语法糖有：泛型、自动装箱、自动拆箱、变长参数、内部类、枚举类、字符串的switch支持等
>
> #### 字节码生成
>
> 编译器会把语句块、变量初始化、调用父类的实例构造器等操作收敛到<init>()或<clinit>()方法之中，并且保证一定是先执行父类的实例构造器。 完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给ClassWriter类，由这个类的writeClass()方法输出字节码，生成最终的Class文件

> # 类加载机制
>
> ```
> 参考：https://blog.csdn.net/javazejian/article/details/73413292
> ```
>
> 当需要使用某个类时，虚拟机将会加载它的".class"文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程称为类加载
>
> Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式即把请求交由父类处理
>
> ### 类加载过程
>
> ```
> 加载 -> 验证 -> 准备 -> 解析 -> 初始化
> ```
>
> ##### 加载
>
> 通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象
>
> ##### 验证
>
> 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全
>
> ##### 准备
>
> 为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值，这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中
>
> ##### 解析
>
> 主要将常量池中的符号引用替换为直接引用的过程
>
> ##### 初始化
>
> 类加载最后阶段，若该类具有超类，则对其进行初始化，执行类构造器(如前面只初始化了默认值的static变量将会在这个阶段赋值)
>
> 静态代码块只在类加载时调用一次
>
> ### 类被加载到jvm的时机
>
> ```
> 参考：https://blog.csdn.net/javazejian/article/details/70768369
> 
> 1.new相应的对象或者调用此类的静态成员/静态方法时
> 2.利用反射来操作此类时
> 3.当加载的一个类拥有父类，并且父类没有被加载时，会先加载其父类
> 4.jvm启动时，会先加载含有main方法的主类
> ```
>
> ### 类卸载
>
> 发⽣时机:
>
> ```
> 此类的所有实例对象都已被回收;
> 加载此类的ClassLoader已经被回收;
> 此类的Class对象没有任何地方在使⽤;
> ```
>
> 卸载过程：
>
> ```
> 回收方法区内此类数据占⽤的内存区域;
> 销毁堆内的Class对象
> ```
>
> 由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。
>
> ### 双亲委派
>
> ```
> 在虚拟机中提供了3种类加载器，
>     根类加载器BootstrapClassLoader
>     扩展类加载器ExtClassLoader
>     应用类加载器AppClassLoader
> ```
>
> 双亲委派模式要求除了顶层根类加载器外，其余的类加载器都应当有自己的父类加载器。如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的根类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。
>
> ##### 双亲委派模式优势
>
> 一：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次
>
> 二：有效避免某些类的恶意加载，防止核心API库被随意篡改
>
> ##### 根类加载器
>
> 根类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库下的jar包加载到内存中
>
> ##### 扩展类加载器
>
> 负责加载<JAVA_HOME>/lib/ext目录下的类库
>
> ##### 应用类加载器
>
> 负责加载系统类路径java -classpath下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。
>
> ### 自定义类加载器
>
> 实现自定义类加载器需要继承ClassLoader或者URLClassLoader，继承ClassLoader则需要自己重写findClass()方法并编写加载逻辑，自定义的类加载器也符合双亲委托模式。
>
> ##### 自定义类加载器的意义
>
> 当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件，在这种情况下我们需要实现一个自定义的ClassLoader来加载特定路径下的class文件生成class对象。
>
> 当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中，这种情况下也需要编写自定义的ClassLoader并实现相应的逻辑。
>
> ### 反射底层原理
>
> 在类的字节码文件被加载到内存时，会根据字节码文件创建一个相应的Class对象用来记录此类的结构信息，后续对象的创建都是根据此Class对象来创建的。
