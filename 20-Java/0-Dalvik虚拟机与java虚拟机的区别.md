# Dalvik虚拟机与java虚拟机的区别

> [Dalvik虚拟机与java虚拟机的区别](https://www.jianshu.com/p/923aebd31b65)
> 
> * java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。
> * Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。
> * java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多。

DVM就是Dalvik Virtual Machine，是Android中使用的虚拟机，所有Android程序都运行在Android系统进程里，每个进程对应着一个Dalvik虚拟机实例。

JAVA虚拟机运行的是JAVA字节码，Dalvik虚拟机运行的是Dalvik字节码（DEX）

* JVM基于栈，DVM基于寄存器
  * JAVA虚拟机基于栈结构，程序在运行时虚拟机需要频繁的从栈上读取写入数据，会耗费很多CPU时间
  * Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递

* Dalvik可执行文件体积更小
  * dx工具对JAVA类文件重新排列，所有的类文件共享同一个常量池，使得相同的字符串、常量在DEX文件中只出现一次

> 作者：RednaxelaFX  
> 链接：https://www.zhihu.com/question/35777031/answer/64575683  
> 来源：知乎  
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

> [虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩](https://www.iteye.com/blog/rednaxelafx-492667)

基于栈与基于寄存器的指令集，用在解释器里，笼统说有以下对比：

* 从源码生成代码的难度：基于栈 < 基于寄存器，不过差别不是特别大
* 表示同样程序逻辑的代码大小（code size）：基于栈 < 基于寄存器
* 表示同样程序逻辑的指令条数（instruction count）：基于栈 > 基于寄存器
* 简易实现中数据移动次数（data movement count）：基于栈 > 基于寄存器；不过值得一提的是实现时通过栈顶缓存（top-of-stack caching）可以大幅降低基于栈的解释器的数据移动开销，可以让这部分开销跟基于寄存器的在同等水平。请参考另一个回答：寄存器分配问题？ - RednaxelaFX 的回答
* 采用同等优化程度的解释器速度：基于栈 < 基于寄存器
* 交由同等优化程度的JIT编译器编译后生成的代码速度：基于栈 === 基于寄存器

因而，笼统说可以有以下结论：

* 要追求尽量实现简单：选择基于栈
* 传输代码的大小尽量小：选择基于栈
* 纯解释执行的解释器的速度：选择基于寄存器
* 带有JIT编译器的执行引擎的速度：随便，两者一样；对简易JIT编译器而言基于栈的指令集可能反而更便于生成更快的代码，而对比较优化的JIT编译器而言输入是基于栈还是基于寄存器都无所谓，经过parse之后就变得完全一样了。

基于栈的设计并没有让Java的代码传输大小减小多少。
这是因为：Java代码是以Class文件为单位来传输与存储的。

Java从设计之初就非要支持分离编译（separate compilation）与按需动态类加载（on-demand dynamic class loading），导致Java的Class文件必须独立的（self-contained）——每个Class文件必须自己携带自己的常量池，其主要信息是字符串与若干其它常量的值，以及用于符号链接的符号引用信息（symbolic reference）。

如果大家关注过Class文件的内容的话，会知道其实通常Class文件里表示程序逻辑的代码部分——“字节码”——只占Class文件大小的小头；而大头都被常量池占了。而且多个Class文件的常量池内容之间常常有重叠，所以当程序涉及多个Class文件时，就容易有冗余信息，不利于减少传输/存储代码的大小。

> **class与dex对比：**

1. class文件存在许多冗余信息，一个类就要有一个常量池
2. dex会去除冗余并整合，所有的源文件中所有的数据是存在一个数据区的，可以减少体积

### ART虚拟机（Android Run Time）

* JIT（Just In Time，即时编译技术）
  * JIT编译器在JVM运行时优化时会详细讲到
* AOT(Ahead Of Time，预编译技术)
  * AOT编译器在编译时直接将程序源码编译成目标机器码，运行时直接运行机器码

ART虚拟机：它采用AOT技术，会在应用程序安装时就转换成机器语言，不再在执行时解释，从而优化了应用运行的速度。

Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。

ART优点：

* 系统性能显著提升
* 应用启动更快、运行更快、体验更流畅、触感反馈更及时

ART缺点：

* 更大的存储空间占用，可能增加10%-20%
* 更长的应用安装时间

总的来说ART就是“空间换时间”