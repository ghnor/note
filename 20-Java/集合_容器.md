# 集合/容器

[Java集合总结【面试题+脑图】，将知识点一网打尽！](https://juejin.im/post/5ad40593f265da23750759ad)

[Java编程的逻辑之容器](https://www.cnblogs.com/swiftma/tag/%E5%AE%B9%E5%99%A8%E7%B1%BB/)

[深入理解Java集合框架](https://github.com/CarpenterLee/JCFInternals)

- ArrayList
  - 数组实现
  - 可以随机访问，按照索引位置进行访问效率很高，用算法描述中的术语，效率是O(1)，简单说就是可以一步到位。
  - 除非数组已排序，否则按照内容查找元素效率比较低，具体是O(N)，N为数组内容长度，也就是说，性能与数组长度成正比。
  - 添加元素的效率还可以，重新分配和拷贝数组的开销被平摊了，具体来说，添加N个元素的效率为O(N)。
  - 插入和删除元素的效率比较低，因为需要移动元素，具体为O(N)。 
- LinkedList
  - 链表实现
  - 增加了一个接口Deque，可以把它看做队列、栈、双端队列，方便的在两端进行操作。
  - 按需分配空间，不需要预先分配很多空间
  - 不可以随机访问，按照索引位置访问效率比较低，必须从头或尾顺着链接找，效率为O(N/2)。
  - 不管列表是否已排序，只要是按照内容查找元素，效率都比较低，必须逐个比较，效率为O(N)。
  - 在两端添加、删除元素的效率很高，为O(1)。
  - 在中间插入、删除元素，要先定位，效率比较低，为O(N)，但修改本身的效率很高，效率为O(1)。 
- HashMap
  - 内部有一个数组table，每个元素table[i]指向一个单向链表，根据键存取值，用键算出hash，取模得到数组中的索引位置buketIndex，然后操作table[buketIndex]指向的单向链表。
  - 根据键保存和获取值的效率都很高，为O(1)，每个单向链表往往只有一个或少数几个节点，根据hash值就可以直接快速定位。
  - HashMap中的键值对没有顺序，因为hash值是随机的。
  - 如果经常需要根据键存取值，而且不要求顺序，那HashMap就是理想的选择。
- HashSet
  - HashMap实现，HashSet相当于只有键，值都是相同的固定值
  - 没有重复元素
  - 可以高效的添加、删除元素、判断元素是否存在，效率都为O(1)。
  - 没有顺序
- 排序二叉树
  - 左子树所有节点都小于该节点
  - 右子树所有节点都大于该节点
  - 排序二叉树保持了元素的顺序，而且是一种综合效率很高的数据结构，基本的保存、删除、查找的效率都为O(h)，h为树的高度，在树平衡的情况下，h为log2(N)，N为节点数，比如，如果N为1024，则log2(N)为10。
  - 基本的排序二叉树不能保证树的平衡，可能退化为一个链表，有很多保持树平衡的算法，AVL树是第一个，能保证树的高度平衡，但红黑树是实际中使用更为广泛的，虽然只能保证大致平衡，但降低了维持树平衡需要的开销，整体统计效果更好。
- TreeMap
  - 内部是用红黑树实现的，红黑树是一种大致平衡的排序二叉树
  - 按键有序，TreeMap同样实现了SortedMap和NavigableMap接口，可以方便的根据键的顺序进行查找，如第一个、最后一个、某一范围的键、邻近键等。
  - 为了按键有序，TreeMap要求键实现Comparable接口或通过构造方法提供一个Comparator对象。
  - 根据键保存、查找、删除的效率比较高，为O(h)，h为树的高度，在树平衡的情况下，h为log2(N)，N为节点数。
- TreeSet
  - 基于TreeMap实现
  - 没有重复元素
  - 添加、删除元素、判断元素是否存在，效率比较高，为O(log2(N))，N为元素个数。
  - 有序，TreeSet同样实现了SortedSet和NavigatableSet接口，可以方便的根据顺序进行查找和操作，如第一个、最后一个、某一取值范围、某一值的邻近元素等。
  - 为了有序，TreeSet要求元素实现Comparable接口或通过构造方法提供一个Comparator对象。
- 堆--完全二叉树
  - 最大堆/最小堆
  - 逻辑上是一颗二叉树，物理上可以用数组存储
- PriorityQueue
  - 实现了优先级队列，最先出队的总是优先级最高的，即排序中的第一个。
  - 优先级可以有相同的，内部元素不是完全有序的，如果遍历输出，除了第一个，其他没有特定顺序。
  - 查看头部元素的效率很高，为O(1)，入队、出队效率比较高，为O(log2(N))，构建堆heapify的效率为O(N)。
  - 根据值查找和删除元素的效率比较低，为O(N)。
- ArrayDeque
  - LinkedList还实现了双端队列接口Deque，Java容器类中还有一个双端队列的实现类ArrayDeque，它是基于数组实现的。
  - 循环数组原理
  - 在两端添加、删除元素的效率很高，动态扩展需要的内存分配以及数组拷贝开销可以被平摊，具体来说，添加N个元素的效率为O(N)。
  - 根据元素内容查找和删除的效率比较低，为O(N)。
  - 与ArrayList和LinkedList不同，没有索引位置的概念，不能根据索引位置进行操作。
- LinkedHashMap
  - 是HashMap的子类，但内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于这个双向链表中。
  - LRUcache
- LinkedHashSet

